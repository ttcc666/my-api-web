# ASP.NET Core Web API 双令牌（Access/Refresh Token）认证改造方案

本文档旨在为您现有的 ASP.NET Core 8 Web API 项目提供一个详尽的、可直接上手的技术实施方案，将其从单一 JWT 认证升级为基于双令牌（Access Token + Refresh Token）的安全认证系统。

---

## 1. 核心设计摘要

参考文章的核心思想是构建一个健壮、安全且用户体验良好的认证体系。其关键设计点如下：

*   **双令牌分离**:
    *   **Access Token (访问令牌)**: 生命周期短（如 15-60 分钟），用于访问受保护的 API 资源。由于其无状态特性，即使被截获，其有效时间窗口也很短，降低了安全风险。
    *   **Refresh Token (刷新令牌)**: 生命周期长（如 7-30 天），存储在数据库中与用户关联。它唯一的作用就是获取新的 Access Token。

*   **核心工作流程**:
    1.  **登录**: 用户凭据验证成功后，服务器生成一对 Access Token 和 Refresh Token 返回给客户端。
    2.  **API 访问**: 客户端在请求头中携带 Access Token 访问受保护的 API。
    3.  **令牌过期**: Access Token 过期后，API 返回 `401 Unauthorized` 错误。
    4.  **无感刷新**: 客户端的请求拦截器捕获到 `401` 错误后，自动携带 Refresh Token 调用 `/api/token/refresh` 接口。
    5.  **令牌轮换 (Rotation)**: 服务器验证 Refresh Token 有效后，会使其失效（防止重放攻击），并生成一对**全新的** Access Token 和 Refresh Token 返回给客户端。
    6.  **重试与存储**: 客户端收到新的令牌后，更新本地存储，并用新的 Access Token 重新发起之前失败的 API 请求。
    7.  **登出**: 客户端请求登出，服务器将对应的 Refresh Token 从数据库中作废（吊销）。

*   **关键优势**:
    *   **高安全性**: 大幅缩短了高权限 Access Token 的暴露窗口，同时 Refresh Token 的服务端存储、轮换和吊销机制能有效应对令牌泄露风险。
    *   **良好用户体验**: 实现自动续期（无感刷新），避免了因 Access Token 过期而频繁要求用户重新登录的问题。

### 流程图 (Mermaid)

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Server as 服务器
    participant DB as 数据库

    Client->>+Server: 1. POST /api/users/login (用户名, 密码)
    Server->>+DB: 验证用户信息
    DB-->>-Server: 用户信息有效
    Server->>Server: 生成 Access Token (短时效)
    Server->>Server: 生成 Refresh Token (长时效)
    Server->>+DB: 存储 Refresh Token, 关联用户
    DB-->>-Server: 存储成功
    Server-->>-Client: 2. 返回 { accessToken, refreshToken }

    loop 访问受保护资源
        Client->>+Server: 3. GET /api/data (Header: Bearer accessToken)
        alt Access Token 有效
            Server-->>-Client: 返回数据
        else Access Token 过期
            Server-->>-Client: 4. 返回 401 Unauthorized
        end
    end

    Client->>+Server: 5. POST /api/token/refresh ({ refreshToken })
    Server->>+DB: 查找并验证 Refresh Token
    DB-->>-Server: Refresh Token 有效
    Server->>+DB: 6. 作废旧的 Refresh Token (Rotation)
    DB-->>-Server: 作废成功
    Server->>Server: 生成新的 Access Token 和 Refresh Token
    Server->>+DB: 存储新的 Refresh Token
    DB-->>-Server: 存储成功
    Server-->>-Client: 7. 返回新的 { accessToken, refreshToken }

    Client->>Client: 8. 更新本地存储的 Tokens
    Client->>+Server: 9. 使用新 Access Token 重试第3步的请求
    Server-->>-Client: 返回数据
```

---

## 2. 分步实施指南

我们将遵循以下步骤完成整个改造过程：

1.  **方案设计与确认**：(已完成)
2.  **环境与配置**：在 `appsettings.json` 中添加 JWT 及双令牌策略所需的安全配置。
3.  **数据模型扩展**：创建 `RefreshToken` 实体类，用于在数据库中持久化和管理刷新令牌。
4.  **核心服务层构建**：创建 `ITokenService` 接口及其实现 `TokenService`，封装所有与令牌相关的业务逻辑。
5.  **中间件与依赖注入**：在 `Program.cs` 中配置 JWT 认证中间件，并注册新的 `TokenService`。
6.  **认证流程改造**：更新登录接口，并创建新的 `TokenController` 用于处理刷新和登出。
7.  **前端集成**：在 Vue 项目的 `src/utils/request.ts` 中实现 Axios 响应拦截器。
8.  **安全加固与测试**：保护 API 端点并进行端到端测试。

---

## 3. 关键代码实现

**注意**: 以下代码已根据您项目中的 `User` 实体和 `SqlSugar` ORM 进行适配。

### 3.1 `appsettings.json` 配置

在 `appsettings.json` 中添加 `JwtSettings` 配置节。

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    // ... 您的数据库连接字符串
  },
  "JwtSettings": {
    "Secret": "A_VERY_LONG_AND_SECURE_SECRET_KEY_REPLACE_IT_LATER_!@#$%",
    "Issuer": "MyApiWeb",
    "Audience": "MyApiWeb.Client",
    "AccessTokenExpirationMinutes": 30,
    "RefreshTokenExpirationDays": 7
  }
}
```

### 3.2 数据模型扩展 (`RefreshToken` 实体)

在 `MyApiWeb.Models` 项目的 `Entities` 文件夹下创建 `RefreshToken.cs`。

```csharp
// File: backend/2-Business/MyApiWeb.Models/Entities/RefreshToken.cs

using SqlSugar;
using System;

namespace MyApiWeb.Models.Entities
{
    [SugarTable("RefreshTokens")]
    public class RefreshToken : EntityBase
    {
        [SugarColumn(IsPrimaryKey = true, IsIdentity = true)]
        public override int Id { get; set; }

        public int UserId { get; set; }

        [SugarColumn(Length = 512)]
        public string Token { get; set; }

        /// <summary>
        /// 关联的 Access Token 的 JWT ID
        /// </summary>
        public string JwtId { get; set; }

        /// <summary>
        /// 是否已被使用（用于实现令牌轮换）
        /// </summary>
        public bool IsUsed { get; set; }

        /// <summary>
        /// 是否已被吊销（用于实现登出）
        /// </summary>
        public bool IsRevoked { get; set; }

        public DateTime CreatedAt { get; set; }

        public DateTime ExpiresAt { get; set; }

        [Navigate(NavigateType.OneToOne, nameof(UserId))]
        public User User { get; set; }
    }
}
```

### 3.3 核心服务层 (`ITokenService` & `TokenService`)

#### 3.3.1 `ITokenService` 接口

在 `MyApiWeb.Services` 项目的 `Interfaces` 文件夹下创建 `ITokenService.cs`。

```csharp
// File: backend/2-Business/MyApiWeb.Services/Interfaces/ITokenService.cs

using MyApiWeb.Models.DTOs;
using MyApiWeb.Models.Entities;
using System.Threading.Tasks;

namespace MyApiWeb.Services.Interfaces
{
    public interface ITokenService
    {
        Task<TokenDto> GenerateTokensAsync(User user);
        Task<(bool IsSuccess, string Error, TokenDto NewTokens)> RefreshTokenAsync(string refreshToken);
        Task<bool> RevokeTokenAsync(string refreshToken);
    }
}
```

#### 3.3.2 `TokenDto` 数据传输对象

在 `MyApiWeb.Models` 项目的 `DTOs` 文件夹下创建 `TokenDto.cs`。

```csharp
// File: backend/2-Business/MyApiWeb.Models/DTOs/TokenDto.cs

namespace MyApiWeb.Models.DTOs
{
    public class TokenDto
    {
        public string AccessToken { get; set; }
        public string RefreshToken { get; set; }
    }
}
```

#### 3.3.3 `TokenService` 实现

在 `MyApiWeb.Services` 项目的 `Implements` 文件夹下创建 `TokenService.cs`。

```csharp
// File: backend/2-Business/MyApiWeb.Services/Implements/TokenService.cs

using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using MyApiWeb.Models.DTOs;
using MyApiWeb.Models.Entities;
using MyApiWeb.Repository.Interfaces;
using MyApiWeb.Services.Interfaces;
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace MyApiWeb.Services.Implements
{
    public class TokenService : ITokenService
    {
        private readonly IConfiguration _configuration;
        private readonly IRepository<RefreshToken> _refreshTokenRepo;
        private readonly IRepository<User> _userRepo;

        public TokenService(IConfiguration configuration, IRepository<RefreshToken> refreshTokenRepo, IRepository<User> userRepo)
        {
            _configuration = configuration;
            _refreshTokenRepo = refreshTokenRepo;
            _userRepo = userRepo;
        }

        public async Task<TokenDto> GenerateTokensAsync(User user)
        {
            var jwtId = Guid.NewGuid().ToString();
            var accessToken = GenerateAccessToken(user, jwtId);
            var refreshToken = await GenerateAndStoreRefreshTokenAsync(user.Id, jwtId);

            return new TokenDto
            {
                AccessToken = accessToken,
                RefreshToken = refreshToken.Token
            };
        }

        public async Task<(bool IsSuccess, string Error, TokenDto NewTokens)> RefreshTokenAsync(string refreshToken)
        {
            var dbToken = await _refreshTokenRepo.GetSingleAsync(rt => rt.Token == refreshToken);

            if (dbToken == null)
                return (false, "Invalid refresh token.", null);

            if (dbToken.IsUsed || dbToken.IsRevoked)
                return (false, "Refresh token has been used or revoked.", null);

            if (dbToken.ExpiresAt < DateTime.UtcNow)
                return (false, "Refresh token has expired.", null);

            // 令牌轮换：立即使当前令牌失效
            dbToken.IsUsed = true;
            await _refreshTokenRepo.UpdateAsync(dbToken);

            var user = await _userRepo.GetByIdAsync(dbToken.UserId);
            if (user == null)
                return (false, "User not found.", null);

            var newTokens = await GenerateTokensAsync(user);
            return (true, null, newTokens);
        }

        public async Task<bool> RevokeTokenAsync(string refreshToken)
        {
            if (string.IsNullOrWhiteSpace(refreshToken))
                return false;

            var dbToken = await _refreshTokenRepo.GetSingleAsync(rt => rt.Token == refreshToken);
            if (dbToken == null || dbToken.IsRevoked)
                return false;

            dbToken.IsRevoked = true;
            dbToken.IsUsed = true; // 登出时也标记为已使用
            await _refreshTokenRepo.UpdateAsync(dbToken);

            return true;
        }

        private string GenerateAccessToken(User user, string jwtId)
        {
            var claims = new List<Claim>
            {
                new Claim(JwtRegisteredClaimNames.Jti, jwtId),
                new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new Claim(ClaimTypes.Name, user.Username),
                // 根据需要添加更多声明，如角色
                // new Claim(ClaimTypes.Role, user.Role)
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JwtSettings:Secret"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var expires = DateTime.UtcNow.AddMinutes(Convert.ToDouble(_configuration["JwtSettings:AccessTokenExpirationMinutes"]));

            var token = new JwtSecurityToken(
                issuer: _configuration["JwtSettings:Issuer"],
                audience: _configuration["JwtSettings:Audience"],
                claims: claims,
                expires: expires,
                signingCredentials: creds
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        private async Task<RefreshToken> GenerateAndStoreRefreshTokenAsync(int userId, string jwtId)
        {
            var refreshToken = new RefreshToken
            {
                Token = GenerateRandomTokenString(),
                JwtId = jwtId,
                UserId = userId,
                CreatedAt = DateTime.UtcNow,
                ExpiresAt = DateTime.UtcNow.AddDays(Convert.ToDouble(_configuration["JwtSettings:RefreshTokenExpirationDays"]))
            };

            await _refreshTokenRepo.InsertAsync(refreshToken);
            return refreshToken;
        }

        private string GenerateRandomTokenString()
        {
            using var rng = RandomNumberGenerator.Create();
            var randomBytes = new byte[64];
            rng.GetBytes(randomBytes);
            return Convert.ToBase64String(randomBytes);
        }
    }
}
```

### 3.4 `Program.cs` 认证配置与依赖注入

修改 `Program.cs` 文件。

```csharp
// File: backend/1-Presentation/MyApiWeb.Api/Program.cs

using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
// ... other usings

var builder = WebApplication.CreateBuilder(args);
var configuration = builder.Configuration;

// ... 其他服务注册

// 1. 注册 TokenService
builder.Services.AddScoped<ITokenService, TokenService>();

// 2. 添加 JWT Bearer 认证
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = configuration["JwtSettings:Issuer"],
        ValidAudience = configuration["JwtSettings:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration["JwtSettings:Secret"])),
        // 允许的服务器时间偏移量, 默认为5分钟, 在此设置为0
        ClockSkew = TimeSpan.Zero
    };

    // 可选：处理因令牌过期导致的认证失败事件，方便前端识别
    options.Events = new JwtBearerEvents
    {
        OnAuthenticationFailed = context =>
        {
            if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
            {
                context.Response.Headers.Append("Token-Expired", "true");
            }
            return Task.CompletedTask;
        }
    };
});

// 3. 添加授权服务
builder.Services.AddAuthorization();

var app = builder.Build();

// ... 中间件配置

// 4. 启用认证和授权中间件 (顺序很重要)
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();
```

### 3.5 认证流程改造

#### 3.5.1 更新登录接口

修改 `UsersController` 中的登录方法。

```csharp
// File: backend/1-Presentation/MyApiWeb.Api/Controllers/UsersController.cs

// ...
private readonly IUserService _userService;
private readonly ITokenService _tokenService;

public UsersController(IUserService userService, ITokenService tokenService)
{
    _userService = userService;
    _tokenService = tokenService;
}

[HttpPost("login")]
[AllowAnonymous]
public async Task<IActionResult> Login([FromBody] LoginRequestDto request)
{
    var (user, error) = await _userService.ValidateUserAsync(request.Username, request.Password);
    if (user == null)
    {
        return Unauthorized(new { message = error });
    }

    var tokens = await _tokenService.GenerateTokensAsync(user);
    return Ok(tokens);
}
// ...
```

#### 3.5.2 创建 `TokenController`

在 `Controllers` 文件夹下创建 `TokenController.cs`。

```csharp
// File: backend/1-Presentation/MyApiWeb.Api/Controllers/TokenController.cs

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using MyApiWeb.Models.DTOs;
using MyApiWeb.Services.Interfaces;
using System.Threading.Tasks;

namespace MyApiWeb.Api.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class TokenController : ControllerBase
    {
        private readonly ITokenService _tokenService;

        public TokenController(ITokenService tokenService)
        {
            _tokenService = tokenService;
        }

        [HttpPost("refresh")]
        [AllowAnonymous]
        public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequestDto request)
        {
            var (isSuccess, error, newTokens) = await _tokenService.RefreshTokenAsync(request.RefreshToken);
            if (!isSuccess)
            {
                return Unauthorized(new { message = error });
            }
            return Ok(newTokens);
        }

        [HttpPost("logout")]
        [Authorize] // 登出需要有效的 Access Token，以确认操作者身份
        public async Task<IActionResult> Logout([FromBody] RefreshTokenRequestDto request)
        {
            var result = await _tokenService.RevokeTokenAsync(request.RefreshToken);
            if (!result)
            {
                return BadRequest(new { message = "Failed to revoke token. It might be invalid or already revoked." });
            }
            return Ok(new { message = "Logged out successfully." });
        }
    }

    // 可以放在 DTOs 文件夹下
    public class RefreshTokenRequestDto
    {
        public string RefreshToken { get; set; }
    }
}
```

### 3.6 前端集成 (Axios 拦截器)

在您的 Vue 项目中，修改 `frontend/src/utils/request.ts`，实现响应拦截器。

```typescript
// File: frontend/src/utils/request.ts

import axios from 'axios';
import { useAuthStore } from '@/stores/auth'; // 假设您使用 Pinia 管理状态

const service = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
});

// 请求拦截器
service.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    if (authStore.accessToken) {
      config.headers['Authorization'] = `Bearer ${authStore.accessToken}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

let isRefreshing = false;
let failedQueue: { resolve: (value: unknown) => void; reject: (reason?: any) => void; }[] = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

// 响应拦截器
service.interceptors.response.use(
  (response) => {
    return response.data;
  },
  async (error) => {
    const originalRequest = error.config;
    const authStore = useAuthStore();

    // 当 Access Token 过期时 (通常是 401)
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        return new Promise(function(resolve, reject) {
          failedQueue.push({ resolve, reject });
        }).then(token => {
          originalRequest.headers['Authorization'] = 'Bearer ' + token;
          return axios(originalRequest);
        }).catch(err => {
          return Promise.reject(err);
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const { refreshToken } = authStore;
        if (!refreshToken) {
            // 如果没有 refresh token，直接跳转到登录页
            authStore.logout();
            return Promise.reject(error);
        }

        const res = await axios.post('/api/token/refresh', { refreshToken });
        const newTokens = res.data;

        authStore.setTokens(newTokens.accessToken, newTokens.refreshToken);
        originalRequest.headers['Authorization'] = `Bearer ${newTokens.accessToken}`;
        
        processQueue(null, newTokens.accessToken);
        return service(originalRequest);

      } catch (refreshError) {
        processQueue(refreshError, null);
        authStore.logout(); // 刷新失败，清空所有信息并登出
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

export default service;
```

---

## 4. 安全最佳实践

*   **Refresh Token 存储**:
    *   **服务端**: 本方案采用将 Refresh Token 存储在数据库中的策略，这是最安全的方式之一，因为它不会暴露给客户端的脚本环境（如 XSS 攻击）。
    *   **客户端**: 如果选择在客户端存储，**必须**使用 `HttpOnly`、`Secure`、`SameSite=Strict` 属性的 Cookie。这可以防止 JavaScript 读取到 Refresh Token，但需要后端配合设置 Cookie。对于前后端分离的 SPA 应用，服务端数据库存储是更常见的选择。

*   **令牌轮换 (Rotation)**: 本方案已实现。每次使用 Refresh Token 后，立即在数据库中将其标记为 `IsUsed`，并签发一个新的 Refresh Token。这能有效防止被盗的 Refresh Token 被重复利用。

*   **防止重放攻击**:
    *   通过令牌轮换，一个 Refresh Token 只能使用一次。
    *   Access Token 中的 `jti` (JWT ID) 声明与 Refresh Token 关联，确保了一对一的关系。

*   **合理的令牌有效期**:
    *   **Access Token**: 建议设置为 15 到 60 分钟。时间越短，风险越小。
    *   **Refresh Token**: 建议设置为 7 到 30 天，在安全性和用户便利性之间取得平衡。

*   **HTTPS**: 生产环境**必须**强制使用 HTTPS，以防止中间人攻击截获任何令牌。

*   **密钥安全**: `appsettings.json` 中的 `JwtSettings:Secret` **绝不能**使用默认值，且**不应**提交到公共代码仓库。在生产环境中，应使用环境变量、Azure Key Vault、AWS Secrets Manager 或 HashiCorp Vault 等工具进行管理。